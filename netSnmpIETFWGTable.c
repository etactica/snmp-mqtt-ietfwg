/*
 * Note: this file originally auto-generated by mib2c using
 *  $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "netSnmpIETFWGTable.h"

/*
 * Typical data structure for a row entry 
 */
struct netSnmpIETFWGTable_entry {
	/*
	 * Index values 
	 */
	char nsIETFWGName[200];
	size_t nsIETFWGName_len;

	/*
	 * Column values 
	 */
	char nsIETFWGChair1[200];
	size_t nsIETFWGChair1_len;
	char old_nsIETFWGChair1[200];
	size_t old_nsIETFWGChair1_len;
	char nsIETFWGChair2[200];
	size_t nsIETFWGChair2_len;
	char old_nsIETFWGChair2[200];
	size_t old_nsIETFWGChair2_len;

	int valid;
};

/*
 * create a new row in the table 
 */
netsnmp_tdata_row *
netSnmpIETFWGTable_createEntry(netsnmp_tdata * table_data,
	char *nsIETFWGName, size_t nsIETFWGName_len) {
	struct netSnmpIETFWGTable_entry *entry;
	netsnmp_tdata_row *row;

	entry = SNMP_MALLOC_TYPEDEF(struct netSnmpIETFWGTable_entry);
	if (!entry)
		return NULL;

	row = netsnmp_tdata_create_row();
	if (!row) {
		SNMP_FREE(entry);
		return NULL;
	}
	row->data = entry;

	DEBUGMSGT(("netSnmpIETFWGTable:entry:create", "row 0x%x\n",
		(uintptr_t) row));
	memcpy(entry->nsIETFWGName, nsIETFWGName, nsIETFWGName_len);
	entry->nsIETFWGName_len = nsIETFWGName_len;
	netsnmp_tdata_row_add_index(row, ASN_OCTET_STR,
		entry->nsIETFWGName, nsIETFWGName_len);
	if (table_data)
		netsnmp_tdata_add_row(table_data, row);
	return row;
}

/*
 * remove a row from the table 
 */
void
netSnmpIETFWGTable_removeEntry(netsnmp_tdata * table_data,
	netsnmp_tdata_row * row) {
	struct netSnmpIETFWGTable_entry *entry;

	if (!row)
		return; /* Nothing to remove */

	DEBUGMSGT(("netSnmpIETFWGTable:entry:remove", "row 0x%x\n",
		(uintptr_t) row));

	entry = (struct netSnmpIETFWGTable_entry *) row->data;
	SNMP_FREE(entry); /* XXX - release any other internal resources */

	if (table_data)
		netsnmp_tdata_remove_and_delete_row(table_data, row);
	else
		netsnmp_tdata_delete_row(row);
}

/** Initializes the netSnmpIETFWGTable module */
netsnmp_tdata *
init_netSnmpIETFWGTable(void) {
	/*
	 * here we initialize all the tables we're planning on supporting 
	 */
	return initialize_table_netSnmpIETFWGTable();
}

/** Initialize the netSnmpIETFWGTable table by defining its contents and how it's structured */
netsnmp_tdata *
initialize_table_netSnmpIETFWGTable(void) {
	const oid netSnmpIETFWGTable_oid[] = {1, 3, 6, 1, 4, 1, 8072, 2, 2, 1};
	const size_t netSnmpIETFWGTable_oid_len =
		OID_LENGTH(netSnmpIETFWGTable_oid);
	netsnmp_handler_registration *reg;
	netsnmp_tdata *table_data;
	netsnmp_table_registration_info *table_info;

	DEBUGMSGTL(("netSnmpIETFWGTable:init",
		"initializing table netSnmpIETFWGTable\n"));

	reg =
		netsnmp_create_handler_registration("netSnmpIETFWGTable",
		netSnmpIETFWGTable_handler,
		netSnmpIETFWGTable_oid,
		netSnmpIETFWGTable_oid_len,
		HANDLER_CAN_RWRITE);

	table_data = netsnmp_tdata_create_table("netSnmpIETFWGTable", 0);
	if (NULL == table_data) {
		snmp_log(LOG_ERR,
			"error creating tdata table for netSnmpIETFWGTable\n");
		return NULL;
	}
	table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
	if (NULL == table_info) {
		snmp_log(LOG_ERR,
			"error creating table info for netSnmpIETFWGTable\n");
		return NULL;
	}
	netsnmp_table_helper_add_indexes(table_info, ASN_OCTET_STR, /* index: nsIETFWGName */
		0);

	table_info->min_column = COLUMN_NSIETFWGCHAIR1;
	table_info->max_column = COLUMN_NSIETFWGCHAIR2;

	netsnmp_tdata_register(reg, table_data, table_info);

	/*
	 * Initialise the contents of the table here 
	 */

	int i;

	char *kwgs[] = {
		"karls working group1",
		"second wg",
		"make it three",
		NULL
	};

	char *knames1[] = {
		"Albert Apple",
		"Andy Awe",
		"Alan Aardvark",
		NULL
	};
	char *knames2[] = {
		"Bill Braggy",
		"Bobby Bush",
		"Bruce Bullwhip",
		NULL
	};

	char *wg;
	i = 0;
	netsnmp_tdata_row *row;
	struct netSnmpIETFWGTable_entry *entry;
	for (wg = kwgs[i]; (wg = kwgs[i]); i++) {
		DEBUGMSGTL(("karl", "adding new row %d for wg: %s\n", i, wg));
		row = netSnmpIETFWGTable_createEntry(table_data, wg, strlen(wg));
		entry = row->data;
		strcpy(entry->nsIETFWGChair1, knames1[i]);
		entry->nsIETFWGChair1_len = strlen(knames1[i]);
		strcpy(entry->nsIETFWGChair2, knames2[i]);
		entry->nsIETFWGChair2_len = strlen(knames2[i]);
	}

	return table_data;
}

/** handles requests for the netSnmpIETFWGTable table */
int
netSnmpIETFWGTable_handler(netsnmp_mib_handler *handler,
	netsnmp_handler_registration *reginfo,
	netsnmp_agent_request_info *reqinfo,
	netsnmp_request_info *requests) {

	netsnmp_request_info *request;
	netsnmp_table_request_info *table_info;
	netsnmp_tdata *table_data;
	netsnmp_tdata_row *table_row;
	struct netSnmpIETFWGTable_entry *table_entry;
	int ret;

	DEBUGMSGTL(("netSnmpIETFWGTable:handler", "Processing request (%d)\n",
		reqinfo->mode));

	switch (reqinfo->mode) {
			/*
			 * Read-support (also covers GetNext requests)
			 */
		case MODE_GET:
			for (request = requests; request; request = request->next) {
				if (request->processed)
					continue;

				table_entry = (struct netSnmpIETFWGTable_entry *)
					netsnmp_tdata_extract_entry(request);
				table_info = netsnmp_extract_table_info(request);

				switch (table_info->colnum) {
					case COLUMN_NSIETFWGCHAIR1:
						if (!table_entry) {
							netsnmp_set_request_error(reqinfo, request,
								SNMP_NOSUCHINSTANCE);
							continue;
						}
						snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
							table_entry->nsIETFWGChair1,
							table_entry->nsIETFWGChair1_len);
						break;
					case COLUMN_NSIETFWGCHAIR2:
						if (!table_entry) {
							netsnmp_set_request_error(reqinfo, request,
								SNMP_NOSUCHINSTANCE);
							continue;
						}
						snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
							table_entry->nsIETFWGChair2,
							table_entry->nsIETFWGChair2_len);
						break;
					default:
						netsnmp_set_request_error(reqinfo, request,
							SNMP_NOSUCHOBJECT);
						break;
				}
			}
			break;

			/*
			 * Write-support
			 */
		case MODE_SET_RESERVE1:
			for (request = requests; request; request = request->next) {
				if (request->processed)
					continue;

				table_entry = (struct netSnmpIETFWGTable_entry *)
					netsnmp_tdata_extract_entry(request);
				table_info = netsnmp_extract_table_info(request);

				switch (table_info->colnum) {
					case COLUMN_NSIETFWGCHAIR1:
						/*
						 * or possibly 'netsnmp_check_vb_type_and_size' 
						 */
						ret =
							netsnmp_check_vb_type_and_max_size(request->requestvb,
							ASN_OCTET_STR,
							sizeof (table_entry->
							nsIETFWGChair1));
						if (ret != SNMP_ERR_NOERROR) {
							netsnmp_set_request_error(reqinfo, request, ret);
							return SNMP_ERR_NOERROR;
						}
						break;
					case COLUMN_NSIETFWGCHAIR2:
						/*
						 * or possibly 'netsnmp_check_vb_type_and_size' 
						 */
						ret =
							netsnmp_check_vb_type_and_max_size(request->requestvb,
							ASN_OCTET_STR,
							sizeof (table_entry->
							nsIETFWGChair2));
						if (ret != SNMP_ERR_NOERROR) {
							netsnmp_set_request_error(reqinfo, request, ret);
							return SNMP_ERR_NOERROR;
						}
						break;
					default:
						netsnmp_set_request_error(reqinfo, request,
							SNMP_ERR_NOTWRITABLE);
						return SNMP_ERR_NOERROR;
				}
			}
			break;

		case MODE_SET_RESERVE2:
			for (request = requests; request; request = request->next) {
				if (request->processed)
					continue;

				table_row = netsnmp_tdata_extract_row(request);
				table_data = netsnmp_tdata_extract_table(request);
				table_info = netsnmp_extract_table_info(request);

				switch (table_info->colnum) {
					case COLUMN_NSIETFWGCHAIR1:
					case COLUMN_NSIETFWGCHAIR2:
						if (!table_row) {
							table_row =
								netSnmpIETFWGTable_createEntry(table_data,
								table_info->
								indexes->val.string,
								table_info->
								indexes->val_len);
							if (table_row) {
								netsnmp_insert_tdata_row(request, table_row);
							} else {
								netsnmp_set_request_error(reqinfo, request,
									SNMP_ERR_RESOURCEUNAVAILABLE);
								return SNMP_ERR_NOERROR;
							}
						}
						break;
				}
			}
			break;

		case MODE_SET_FREE:
			for (request = requests; request; request = request->next) {
				if (request->processed)
					continue;

				table_entry = (struct netSnmpIETFWGTable_entry *)
					netsnmp_tdata_extract_entry(request);
				table_row = netsnmp_tdata_extract_row(request);
				table_data = netsnmp_tdata_extract_table(request);
				table_info = netsnmp_extract_table_info(request);

				switch (table_info->colnum) {
					case COLUMN_NSIETFWGCHAIR1:
					case COLUMN_NSIETFWGCHAIR2:
						if (table_entry && !table_entry->valid) {
							netSnmpIETFWGTable_removeEntry(table_data, table_row);
						}
						break;
				}
			}
			break;

		case MODE_SET_ACTION:
			for (request = requests; request; request = request->next) {
				if (request->processed)
					continue;

				table_entry = (struct netSnmpIETFWGTable_entry *)
					netsnmp_tdata_extract_entry(request);
				table_info = netsnmp_extract_table_info(request);

				switch (table_info->colnum) {
					case COLUMN_NSIETFWGCHAIR1:
						memcpy(table_entry->old_nsIETFWGChair1,
							table_entry->nsIETFWGChair1,
							sizeof (table_entry->nsIETFWGChair1));
						table_entry->old_nsIETFWGChair1_len =
							table_entry->nsIETFWGChair1_len;
						memset(table_entry->nsIETFWGChair1, 0,
							sizeof (table_entry->nsIETFWGChair1));
						memcpy(table_entry->nsIETFWGChair1,
							request->requestvb->val.string,
							request->requestvb->val_len);
						table_entry->nsIETFWGChair1_len =
							request->requestvb->val_len;
						break;
					case COLUMN_NSIETFWGCHAIR2:
						memcpy(table_entry->old_nsIETFWGChair2,
							table_entry->nsIETFWGChair2,
							sizeof (table_entry->nsIETFWGChair2));
						table_entry->old_nsIETFWGChair2_len =
							table_entry->nsIETFWGChair2_len;
						memset(table_entry->nsIETFWGChair2, 0,
							sizeof (table_entry->nsIETFWGChair2));
						memcpy(table_entry->nsIETFWGChair2,
							request->requestvb->val.string,
							request->requestvb->val_len);
						table_entry->nsIETFWGChair2_len =
							request->requestvb->val_len;
						break;
				}
			}
			break;

		case MODE_SET_UNDO:
			for (request = requests; request; request = request->next) {
				if (request->processed)
					continue;

				table_entry = (struct netSnmpIETFWGTable_entry *)
					netsnmp_tdata_extract_entry(request);
				table_row = netsnmp_tdata_extract_row(request);
				table_data = netsnmp_tdata_extract_table(request);
				table_info = netsnmp_extract_table_info(request);

				switch (table_info->colnum) {
					case COLUMN_NSIETFWGCHAIR1:
						if (table_entry && !table_entry->valid) {
							netSnmpIETFWGTable_removeEntry(table_data, table_row);
						} else {
							memcpy(table_entry->nsIETFWGChair1,
								table_entry->old_nsIETFWGChair1,
								sizeof (table_entry->nsIETFWGChair1));
							memset(table_entry->old_nsIETFWGChair1, 0,
								sizeof (table_entry->nsIETFWGChair1));
							table_entry->nsIETFWGChair1_len =
								table_entry->old_nsIETFWGChair1_len;
						}
						break;
					case COLUMN_NSIETFWGCHAIR2:
						if (table_entry && !table_entry->valid) {
							netSnmpIETFWGTable_removeEntry(table_data, table_row);
						} else {
							memcpy(table_entry->nsIETFWGChair2,
								table_entry->old_nsIETFWGChair2,
								sizeof (table_entry->nsIETFWGChair2));
							memset(table_entry->old_nsIETFWGChair2, 0,
								sizeof (table_entry->nsIETFWGChair2));
							table_entry->nsIETFWGChair2_len =
								table_entry->old_nsIETFWGChair2_len;
						}
						break;
				}
			}
			break;

		case MODE_SET_COMMIT:
			for (request = requests; request; request = request->next) {
				if (request->processed)
					continue;

				table_entry = (struct netSnmpIETFWGTable_entry *)
					netsnmp_tdata_extract_entry(request);
				table_info = netsnmp_extract_table_info(request);

				switch (table_info->colnum) {
					case COLUMN_NSIETFWGCHAIR1:
					case COLUMN_NSIETFWGCHAIR2:
						if (table_entry && !table_entry->valid) {
							table_entry->valid = 1;
						}
				}
			}
			break;
	}
	return SNMP_ERR_NOERROR;
}

static
netsnmp_tdata_row *
_find_row(netsnmp_tdata *table_data, const char *wgname) {
	netsnmp_variable_list wgname_var;
	netsnmp_tdata_row *row;
	memset(&wgname_var, 0, sizeof (netsnmp_variable_list));
	snmp_set_var_typed_value(&wgname_var, ASN_OCTET_STR, wgname, strlen(wgname));
	return netsnmp_tdata_row_get_byidx(table_data, &wgname_var);
}

void netSnmpIETFWGTable_simple_addupdate(netsnmp_tdata *table_data,
	const char *wgname,
	const char *wgchair1, const char *wgchair2) {

	netsnmp_tdata_row *row = _find_row(table_data, wgname);
	if (!row) {
		/* Create if it's new, */
		row = netSnmpIETFWGTable_createEntry(table_data, wgname, strlen(wgname));
	}
	/* then just do the update */
	struct netSnmpIETFWGTable_entry *entry = row->data;
	if (wgchair1) {
		strcpy(entry->nsIETFWGChair1, wgchair1);
		entry->nsIETFWGChair1_len = strlen(wgchair1);
	} else {
		/* don't need to actually zero out the data...*/
		entry->nsIETFWGChair1_len = 0;
	}
	if (wgchair2) {
		strcpy(entry->nsIETFWGChair2, wgchair2);
		entry->nsIETFWGChair2_len = strlen(wgchair2);
	} else {
		entry->nsIETFWGChair2_len = 0;
	}
}

void netSnmpIETFWGTable_simple_remove(netsnmp_tdata *table_data, const char *wgname) {
	netsnmp_tdata_row *row = _find_row(table_data, wgname);
	if (row) {
		DEBUGMSGTL(("verbose", "Found row with wgname, deleting it: %s\n", wgname));
		netSnmpIETFWGTable_removeEntry(table_data, row);
	} else {
		DEBUGMSGTL(("verbose", "No row found with wgname: %s\n", wgname));
	}
}
